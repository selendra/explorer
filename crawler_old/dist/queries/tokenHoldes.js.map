{"version":3,"file":"tokenHoldes.js","sourceRoot":"/","sources":["queries/tokenHoldes.ts"],"names":[],"mappings":"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","sourcesContent":["import { TokenHolder } from '../crawler/types';\nimport { insertV2 } from '../utils/connector';\nimport logger from '../utils/logger';\nimport { dropDuplicatesMultiKey } from '../utils/utils';\n\nconst TOKEN_HOLDER_INSERT_STATEMENT = `\nINSERT INTO token_holder\n  (signer, evm_address, type, token_address, nft_id, balance, info, timestamp)\nVALUES\n  %L`;\n\nconst DO_UPDATE = ` balance = EXCLUDED.balance,\n  timestamp = EXCLUDED.timestamp,\n  info = EXCLUDED.info;`;\n\nconst toTokenHolder = ({\n  signerAddress,\n  balance,\n  tokenAddress,\n  info,\n  evmAddress,\n  type,\n  timestamp,\n  nftId,\n}: TokenHolder): any[] => [signerAddress === '' ? null : signerAddress, evmAddress === '' ? null : evmAddress, type, tokenAddress, nftId, balance, JSON.stringify(info !== null ? info : {}), timestamp];\n\nexport const insertAccountTokenHolders = async (tokenHolders: TokenHolder[]): Promise<void> => insertV2(\n  `${TOKEN_HOLDER_INSERT_STATEMENT}\n    ON CONFLICT (signer, token_address) WHERE evm_address IS NULL AND nft_id IS NULL DO UPDATE SET\n    ${DO_UPDATE}\n  `,\n  tokenHolders.map(toTokenHolder),\n);\n\nexport const insertContractTokenHolders = async (tokenHolders: TokenHolder[]): Promise<void> => insertV2(\n  `${TOKEN_HOLDER_INSERT_STATEMENT}\n    ON CONFLICT (evm_address, token_address) WHERE signer IS NULL AND nft_id IS NULL DO UPDATE SET\n    ${DO_UPDATE}\n  `,\n  tokenHolders.map(toTokenHolder),\n);\n\nexport const insertAccountNftHolders = async (tokenHolders: TokenHolder[]): Promise<void> => insertV2(\n  `${TOKEN_HOLDER_INSERT_STATEMENT}\n    ON CONFLICT (signer, token_address, nft_id) WHERE evm_address IS NULL AND nft_id IS NOT NULL DO UPDATE SET\n    ${DO_UPDATE}\n  `,\n  tokenHolders.map(toTokenHolder),\n);\n\nexport const insertContractNftHolders = async (tokenHolders: TokenHolder[]): Promise<void> => insertV2(\n  `${TOKEN_HOLDER_INSERT_STATEMENT}\n    ON CONFLICT (evm_address, token_address, nft_id) WHERE signer IS NULL AND nft_id IS NOT NULL DO UPDATE SET\n    ${DO_UPDATE}\n  `,\n  tokenHolders.map(toTokenHolder),\n);\n\nexport default async (tokenHolders: TokenHolder[]): Promise<void> => {\n  logger.info('Inserting account nft holders');\n  await insertAccountNftHolders(\n    dropDuplicatesMultiKey(\n      tokenHolders.filter(({ type, nftId }) => type === 'Account' && nftId !== null),\n      ['signerAddress', 'tokenAddress', 'nftId'],\n    ),\n  );\n  logger.info('Inserting contract nft holders');\n  await insertContractNftHolders(\n    dropDuplicatesMultiKey(\n      tokenHolders.filter(({ type, nftId }) => type === 'Contract' && nftId !== null),\n      ['evmAddress', 'tokenAddress', 'nftId'],\n    ),\n  );\n  logger.info('Inserting account token holders');\n  await insertAccountTokenHolders(\n    dropDuplicatesMultiKey(\n      tokenHolders.filter(({ type, nftId }) => type === 'Account' && nftId === null),\n      ['signerAddress', 'tokenAddress'],\n    ),\n  );\n  logger.info('Inserting contract token holders');\n  await insertContractTokenHolders(\n    dropDuplicatesMultiKey(\n      tokenHolders.filter(({ type, nftId }) => type === 'Contract' && nftId === null),\n      ['evmAddress', 'tokenAddress'],\n    ),\n  );\n};\n"]}