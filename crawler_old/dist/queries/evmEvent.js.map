{"version":3,"file":"evmEvent.js","sourceRoot":"/","sources":["queries/evmEvent.ts"],"names":[],"mappings":"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","sourcesContent":["import { GenericEventData } from '@polkadot/types/generic/Event';\nimport { utils as ethersUtils } from 'ethers/lib/ethers';\nimport format from 'pg-format';\nimport {\n  BacktrackingEvmEvent, BytecodeLog, CompleteEvmData, Contract, DecodedEvmError, ERC20Token, EventBody, EVMEventData, VerifiedContract,\n} from '../crawler/types';\nimport {\n  insert, query, queryv2,\n} from '../utils/connector';\nimport { toChecksumAddress } from '../utils/utils';\n\nconst contractToValues = ({\n  address,\n  extrinsicId,\n  bytecode,\n  bytecodeContext,\n  bytecodeArguments,\n  gasLimit,\n  storageLimit,\n  signer,\n  timestamp,\n}: Contract): string => {\n  const contractAddress = toChecksumAddress(address);\n  return contractAddress ? `('${contractAddress}', ${extrinsicId}, '${signer}', '${bytecode}', '${bytecodeContext}', '${bytecodeArguments}', ${gasLimit}, ${storageLimit}, '${timestamp}')` : '';\n};\n\nexport const getContractDB = async (\n  address: string,\n): Promise<VerifiedContract[]> => {\n  const contractAddress = toChecksumAddress(address);\n  return contractAddress\n    ? query<VerifiedContract>(\n      `SELECT address, contract_data, compiled_data, name, type FROM verified_contract WHERE address='${contractAddress}';`,\n    )\n    : [];\n};\n\nexport const insertContracts = async (contracts: Contract[]): Promise<void> => {\n  if (contracts.length === 0) {\n    return;\n  }\n  await insert(`\n    INSERT INTO contract\n      (address, extrinsic_id, signer, bytecode, bytecode_context, bytecode_arguments, gas_limit, storage_limit, timestamp)\n    VALUES\n      ${contracts.map(contractToValues).filter((v) => !!v).join(',\\n')}\n    ON CONFLICT (address) DO UPDATE\n      SET extrinsic_id = EXCLUDED.extrinsic_id,\n        bytecode = EXCLUDED.bytecode,\n        gas_limit = EXCLUDED.gas_limit,\n        timestamp = EXCLUDED.timestamp,\n        storage_limit = EXCLUDED.storage_limit,\n        bytecode_context = EXCLUDED.bytecode_context,\n        bytecode_arguments = EXCLUDED.bytecode_arguments;\n  `);\n};\n\nexport const insertContract = async (contract: Contract): Promise<void> => insertContracts([contract]);\n\nexport const getERC20Tokens = async (): Promise<ERC20Token[]> => query<ERC20Token>(\n  'SELECT address, contract_data, name FROM verified_contract WHERE type=\\'ERC20\\';',\n);\n\nconst parseEvmLogData = async (method: string, genericData: GenericEventData): Promise<undefined|CompleteEvmData> => {\n  const eventData = (genericData.toJSON() as any);\n  if (method === 'Log') {\n    const { topics, data } : BytecodeLog = eventData[0];\n    let { address } : BytecodeLog = eventData[0];\n    address = toChecksumAddress(address);\n    if (!address) {\n      return undefined;\n    }\n    const evmData: CompleteEvmData = {\n      raw: { address, topics, data }, parsed: {}, status: 'Success', type: 'Unverified',\n    };\n    const contract = await getContractDB(address);\n    if (contract.length === 0) {\n      return evmData;\n    }\n    const iface = new ethersUtils.Interface(contract[0].compiled_data[contract[0].name]);\n    try {\n      evmData.parsed = iface.parseLog({ topics, data });\n      evmData.type = 'Verified';\n    } catch {\n      //\n    }\n    return evmData;\n  } if (method === 'ExecutedFailed') {\n    let decodedMessage;\n    try {\n      decodedMessage = eventData[2] === '0x' ? '' : ethersUtils.toUtf8String(`0x${eventData[2].substr(138)}`.replace(/0+$/, ''));\n    } catch {\n      decodedMessage = '';\n    }\n    const decodedError: DecodedEvmError = { address: eventData[0], message: decodedMessage };\n    return {\n      parsed: decodedError, raw: { address: decodedError.address, data: '', topics: [] }, status: 'Error', type: 'Verified',\n    };\n  }\n  return undefined;\n};\n\nconst toEventData = (eventBody: EventBody): EVMEventData => ({\n  id: eventBody.id,\n  timestamp: eventBody.timestamp,\n  data: eventBody.event.event.data,\n  section: eventBody.event.event.section,\n  method: eventBody.event.event.method,\n  blockId: eventBody.blockId,\n  eventIndex: eventBody.index,\n  extrinsicIndex: eventBody.extrinsicIndex,\n});\n\nconst evmEventDataToInsertValue = async ({\n  id,\n  data,\n  method,\n  blockId,\n  eventIndex,\n  extrinsicIndex,\n}: EVMEventData): Promise<string | null> => {\n  const parsedEvmData = await parseEvmLogData(method, data);\n  if (!parsedEvmData) {\n    return null;\n  }\n  const topics = parsedEvmData.raw.topics || [];\n  const parsedEvmString = parsedEvmData.parsed ? JSON.stringify(parsedEvmData.parsed) : undefined;\n\n  return `(${id}, '${parsedEvmData.raw.address}', '${JSON.stringify(parsedEvmData.raw)}', '${parsedEvmString}', '${method}', '${topics[0]}', '${topics[1]}', '${topics[2]}', '${topics[3]}', ${blockId}, ${extrinsicIndex}, ${eventIndex}, '${parsedEvmData.status}', '${parsedEvmData.type}')`;\n};\n\n// TODO deprecating\nexport const insertEvmEvents = async (evmEvents: EventBody[]): Promise<void> => {\n  if (evmEvents.length < 1) {\n    return;\n  }\n  const insertValuePromises = evmEvents\n    .filter(({ event: { event: { section, method } } }) => section === 'evm' && (method === 'ExecutedFailed' || method === 'Log'))\n    .map(toEventData)\n    .map(evmEventDataToInsertValue);\n  const evmEventInputValues = (await Promise.all(insertValuePromises)).filter((v) => !!v);\n\n  if (evmEventInputValues.length) {\n    await insert(`\n      INSERT INTO evm_event\n      (event_id, contract_address, data_raw, data_parsed, method, topic_0, topic_1, topic_2, topic_3, block_id, extrinsic_index, event_index, status, type)\n      VALUES\n      ${evmEventInputValues.join(',\\n')};\n    `);\n  }\n};\n\ninterface InsertEvmLog extends CompleteEvmData {\n  eventId: number;\n  blockId: number;\n  eventIndex: number;\n  extrinsicIndex: number;\n  method: 'Log' | 'ExecutedFailed',\n  status: 'Success' | 'Error';\n  type: 'Verified' | 'Unverified';\n}\n\nexport const insertEvmLog = async (logs: InsertEvmLog[]): Promise<void> => {\n  if (logs.length > 0) {\n    await queryv2(\n      format(\n        `\n        INSERT INTO evm_event\n          (event_id, contract_address, data_raw, data_parsed, method, topic_0, topic_1, topic_2, topic_3, block_id, extrinsic_index, event_index, status, type)\n        VALUES \n          %L;\n      `,\n        logs.map((log) => [\n          log.eventId,\n          log.raw.address,\n          JSON.stringify(log.raw),\n          JSON.stringify(log.parsed) || null,\n          log.method,\n          log.raw.topics[0] || null,\n          log.raw.topics[1] || null,\n          log.raw.topics[2] || null,\n          log.raw.topics[3] || null,\n          log.blockId,\n          log.extrinsicIndex,\n          log.eventIndex,\n          log.status,\n          log.type,\n        ]),\n      ),\n    );\n  }\n};\n\nexport const updateEvmEvents = async (evmEvents: BacktrackingEvmEvent[]): Promise<void> => {\n  if (!evmEvents.length) { return; }\n\n  await queryv2(\n    format(\n      `INSERT INTO evm_event\n        (id, event_id, block_id, event_index, extrinsic_index, contract_address, data_raw, method, status, type, data_parsed)\n      VALUES\n        %L\n      ON CONFLICT (id) DO UPDATE SET\n        type = EXCLUDED.type,\n        data_parsed = EXCLUDED.data_parsed\n        `,\n      evmEvents.map(({\n        id, status, type, method, blockid, parseddata, extrinsicindex, eventindex, eventid, contractaddress, rawdata,\n      }) => [id, eventid, blockid, eventindex, extrinsicindex, contractaddress, rawdata, method, status, type, parseddata]),\n    ),\n  );\n};\n"]}