{"version":3,"file":"crawlerV2.js","sourceRoot":"/","sources":["crawlerV2.ts"],"names":[],"mappings":"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","sourcesContent":["import { RewriteFrames } from '@sentry/integrations';\nimport * as Sentry from '@sentry/node';\nimport config from './config';\nimport syncVerifiedContracts from './crawler/syncVerifiedContracts';\nimport processBlock, { processUnfinalizedBlock } from './crawlerv2/block';\nimport { deleteUnfinishedBlocks, lastBlockInDatabase } from './queries/block';\nimport { nodeProvider } from './utils/connector';\nimport logger from './utils/logger';\nimport Performance from './utils/Performance';\nimport Queue from './utils/Queue';\nimport { promiseWithTimeout, wait } from './utils/utils';\n// Importing @sentry/tracing patches the global hub for tracing to work.\n// import * as Tracing from \"@sentry/tracing\";\n\n/* eslint \"no-underscore-dangle\": \"off\" */\nSentry.init({\n  dsn: config.sentryDns,\n  tracesSampleRate: 1.0,\n  integrations: [\n    new RewriteFrames({\n      root: global.__dirname,\n    }),\n  ],\n  environment: config.environment,\n});\nSentry.setTag('component', 'crawler');\nSentry.setTag('network', config.network);\n\nconsole.warn = () => {};\n\nconst crawler = async () => {\n  let updateVerifiedContracts = 0;\n  let currentBlockIndex = await lastBlockInDatabase();\n  currentBlockIndex++;\n  const queue = new Queue<Promise<void>>(config.maxBlocksPerStep);\n  const per = new Performance(config.maxBlocksPerStep);\n\n  nodeProvider.getProvider().api.rpc.chain.subscribeNewHeads(async (header) => {\n    await processUnfinalizedBlock(header.number.toNumber());\n  });\n\n  while (true) {\n    const finalizedHead = nodeProvider.lastFinalizedBlockId();\n\n    // Starting to process some amount of blocks\n    while (currentBlockIndex <= finalizedHead && !queue.isFull()) {\n      queue.push(processBlock(currentBlockIndex));\n      currentBlockIndex++;\n    }\n\n    // If queue is empty crawler has nothing to do\n    if (queue.isEmpty()) {\n      await wait(config.pollInterval);\n      continue;\n    }\n\n    // Waiting for the first block to finish and measuring performance\n    const start = Date.now();\n    await queue.pop();\n    const diff = Date.now() - start;\n    per.push(diff);\n    per.log();\n\n    /**\n     * Verification contract sync will only be triggered when:\n     * - sync is enabled\n     * - crawler is in \"listening\" mode\n     * - on every nth interval\n     */\n    updateVerifiedContracts += 1;\n    if (\n      config.verifiedContractSync\n       && (finalizedHead - currentBlockIndex) <= 3\n       && updateVerifiedContracts > config.verifiedContractSyncInterval\n    ) {\n      await syncVerifiedContracts();\n      updateVerifiedContracts = 0;\n    }\n  }\n};\n\nPromise.resolve()\n  .then(async () => {\n    await nodeProvider.initializeProviders();\n    logger.info('Removing unfinished blocks...');\n    await deleteUnfinishedBlocks();\n  })\n  .then(() => {\n    logger.info(`Contract verification sync: ${config.verifiedContractSync}`);\n  })\n  .then(crawler)\n  .then(async () => {\n    await nodeProvider.closeProviders();\n    logger.info('Finished');\n    process.exit();\n  })\n  .catch(async (error) => {\n    logger.error(error);\n    Sentry.captureException(error);\n\n    try {\n      await promiseWithTimeout(nodeProvider.closeProviders(), 200, Error('Failed to close proivders!'));\n    } catch (err) {\n      Sentry.captureException(err);\n    }\n\n    logger.error('Finished');\n    Sentry.close(2000).then(() => {\n      process.exit(-1);\n    });\n  });\n"]}