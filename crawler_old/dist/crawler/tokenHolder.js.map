{"version":3,"file":"tokenHolder.js","sourceRoot":"/","sources":["crawler/tokenHolder.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  SELENDRA_CONTRACT_ADDRESS, resolvePromisesAsChunks, SELENDRA_DEFAULT_DATA, dropDuplicatesMultiKey, dropDuplicates, removeUndefinedItem,\n} from '../utils/utils';\nimport {\n  isErc20TransferEvent, isErc721TransferEvent, isErc1155TransferSingleEvent, isErc1155TransferBatchEvent,\n} from './evmEvent';\nimport {\n  TokenHolder, EvmLogWithDecodedEvent, TokenHolderHead, TokenType, AccountBody,\n} from './types';\nimport { balanceOf, balanceOfErc1155, findNativeAddress } from './utils';\n\nconst prepareTokenHolderHead = (evmAddress: string, nftId: null | string, type: TokenType, {\n  timestamp, address: tokenAddress, contractData, abis, name,\n}: EvmLogWithDecodedEvent): TokenHolderHead => ({\n  type,\n  nftId,\n  timestamp,\n  evmAddress,\n  tokenAddress,\n  abi: abis[name],\n  info: contractData,\n});\n\nconst processTokenHolderHead = async (head: TokenHolderHead, balance: string): Promise<TokenHolder> => {\n  const native = await findNativeAddress(head.evmAddress);\n  return {\n    ...head,\n    balance,\n    signerAddress: native,\n    evmAddress: native !== '' ? '' : head.evmAddress,\n    type: native !== '' ? 'Account' : 'Contract',\n  };\n};\n\nconst base = (from: string, to: string, nft: null | string, type: TokenType, log: EvmLogWithDecodedEvent): TokenHolderHead[] => [\n  prepareTokenHolderHead(to, nft, type, log),\n  prepareTokenHolderHead(from, nft, type, log),\n];\n\nconst evmLogToTokenHolderHead = (log: EvmLogWithDecodedEvent): TokenHolderHead[] => {\n  if (isErc20TransferEvent(log)) {\n    const [from, to] = log.decodedEvent.args;\n    return base(from, to, null, 'ERC20', log);\n  }\n  if (isErc721TransferEvent(log)) {\n    const [from, to, nft] = log.decodedEvent.args;\n    return base(from, to, nft.toString(), 'ERC721', log);\n  }\n  if (isErc1155TransferSingleEvent(log)) {\n    const [, from, to, nft] = log.decodedEvent.args;\n    return base(from, to, nft.toString(), 'ERC1155', log);\n  }\n  if (isErc1155TransferBatchEvent(log)) {\n    const [, from, to, nfts] = log.decodedEvent.args;\n    return (nfts as [])\n      .flatMap((_, index) => base(from, to, nfts[index].toString(), 'ERC1155', log));\n  }\n  return [];\n};\n\nexport const processEvmTokenHolders = async (evmLogs: EvmLogWithDecodedEvent[]): Promise<TokenHolder[]> => {\n  const tokenHolders = dropDuplicatesMultiKey(\n    evmLogs.flatMap(evmLogToTokenHolderHead),\n    ['evmAddress', 'tokenAddress', 'nftId'],\n  )\n    .filter(({ evmAddress }) => evmAddress !== '0x0000000000000000000000000000000000000000')\n    // Balance of function is surrounded by a try-catch statement because every contract can be deleted.\n    // If a contract is deleted there is no on-chain data and the old data can not be reached.\n    // Therefore we are capturing these events and filtering them out.\n    .map(async (head) => {\n      try {\n        const balance = head.type === 'ERC1155'\n          ? await balanceOfErc1155(head.evmAddress, head.tokenAddress, head.nftId!, head.abi)\n          : await balanceOf(head.evmAddress, head.tokenAddress, head.abi);\n        return processTokenHolderHead(head, balance);\n      } catch (e) {\n        return undefined;\n      }\n    });\n\n  const results = await resolvePromisesAsChunks(tokenHolders);\n  return results.filter(removeUndefinedItem);\n};\n\nexport const processNativeTokenHolders = (accounts: AccountBody[]): TokenHolder[] => dropDuplicates(accounts, 'address')\n  .map(({ address, timestamp, freeBalance }): TokenHolder => ({\n    timestamp,\n    signerAddress: address,\n    tokenAddress: SELENDRA_CONTRACT_ADDRESS,\n    info: { ...SELENDRA_DEFAULT_DATA },\n    balance: freeBalance,\n    type: 'Account',\n    evmAddress: '',\n    nftId: null,\n  }));\n"]}